{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p><code>rich-color-ext</code> extends the Rich library to parse 3-digit hex colors (for example <code>#09F</code>) and CSS color names (for example <code>rebeccapurple</code>).</p> <p>This project allows Rich users to write color names or short hex codes and have them correctly parsed into Rich Color instances.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Parse 3-digit hex colors like <code>#abc</code> \u2192 <code>#AABBCC</code>.</li> <li>Parse CSS color names (e.g. <code>&lt;span style=\"color:rebeccapurple;\"&gt;rebeccapurple&lt;/span&gt;</code>, <code>&lt;span style=\"color:mediumslateblue;\"&gt;mediumslateblue&lt;/span&gt;</code>).</li> <li>Lightweight monkey-patch to Rich's <code>Color.parse</code> to add the above support.</li> </ul> <p>For installation instructions, usage examples, packaging notes and more, see the sections linked from the navigation.</p> Next: Usage"},{"location":"contact/","title":"Contact","text":"<p>Project: rich-color-ext</p> <p>Author: Max Ludden</p> <p>Email: dev@maxludden.com</p> <p>GitHub: https://github.com/maxludden/rich-color-ext</p> <p>If you'd like help, bug reports or feature requests, please open an issue on the project's GitHub repository. For quick questions you can also email the address above.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#installing","title":"Installing","text":"<p>Install from PyPI:</p> <pre><code>pip install rich-color-ext\n</code></pre> <p>Or using <code>uv</code> (recommended for some workflows):</p> <pre><code># via uv directly\nuv add rich-color-ext\n\n# or via pip through uv\nuv pip add rich-color-ext\n</code></pre>"},{"location":"usage/#basic-usage","title":"Basic usage","text":"<p>To enable the extended parsing behaviour, import and call <code>install()</code> once at startup in your program.</p> <pre><code>from rich_color_ext import install\nfrom rich.console import Console\n\ninstall()  # Patch Rich's Color.parse method\n\nconsole = Console(width=64)\nconsole.print(\"This text can include CSS colors like [bold rebeccapurple]rebeccapurple[/] or 3-digit hex like [#f0f]#f0f[/].\")\n</code></pre> <p>The package also provides <code>CSSColor</code> helpers and a <code>get_css_map()</code> function to inspect the canonical list of supported CSS named colours.</p>"},{"location":"usage/#logging-troubleshooting","title":"Logging / Troubleshooting","text":"<p>The package uses <code>loguru</code> internally but keeps the logger disabled by default. Enable it at runtime to see diagnostic information:</p> <pre><code>from rich_color_ext import log\nlog.enable(\"rich_color_ext\")\n# ... do things that exercise the library ...\nlog.disable(\"rich_color_ext\")\n</code></pre>"},{"location":"usage/#packaging-notes-pyinstaller","title":"Packaging notes (PyInstaller)","text":"<p>The CSS map is embedded in the package so a separate <code>colors.json</code> is usually not required. See the README for legacy packaging tips if you need to include the JSON resource manually.</p>"},{"location":"reference/","title":"API Reference","text":"<p>Below are auto-generated API docs for the primary modules in this package.</p> <p>Rich Color Extensions Package.</p> <p>This package extends the Rich library's color parsing capabilities by adding support for: - 3-digit hexadecimal color codes (e.g., <code>#abc</code>). - CSS color names (e.g., <code>rebeccapurple</code>, <code>mediumslateblue</code>). It achieves this by patching the <code>Color.parse</code> method in Rich with an extended parser.</p>"},{"location":"reference/#rich_color_ext.CSSColor","title":"<code>CSSColor</code>","text":"<p>Class to handle CSS color names and their corresponding hex values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>class CSSColor:\n    \"\"\"Class to handle CSS color names and their corresponding hex values.\"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        hex: Optional[str] = None,  # pylint:disable=W0622\n        red: Optional[int] = None,\n        green: Optional[int] = None,\n        blue: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Create a CSSColor.\n\n        You may provide any combination of name/hex/RGB sufficient to derive the\n        remaining attributes. Values are normalised and validated.\n        \"\"\"\n        log.debug(f\"Creating CSSColor({name=}, {hex=}, {red=}, {green=}, {blue=})\")\n\n        self._name = \"\"\n        self._hex = \"\"\n        self._red = -1\n        self._green = -1\n        self._blue = -1\n\n        # Apply provided values through property setters to keep invariants.\n        if name is not None:\n            self.name = name\n        if hex is not None:\n            self.hex = hex\n        # Only set numeric channels if caller provided them (None means omitted)\n        if red is not None:\n            self.red = red\n        if green is not None:\n            self.green = green\n        if blue is not None:\n            self.blue = blue\n\n        # Fill missing values when possible\n        if self._name and not self._hex and self._name in get_css_map():\n            self.hex = get_css_map()[self._name]\n\n        if self._hex and (self._red &lt; 0 or self._green &lt; 0 or self._blue &lt; 0):\n            r, g, b = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = r, g, b\n\n        if not self._name and self._hex:\n            css_map = get_css_map() or get_css_map()\n            derived = _find_name_by_hex(self._hex, css_map)\n            if derived:\n                self._name = derived\n\n        # Final validation\n        if (\n            not self._name\n            or not self._hex\n            or any(v &lt; 0 or v &gt; 255 for v in (self._red, self._green, self._blue))\n        ):\n            raise ValueError(\"Unable to determine color.\")\n\n    @classmethod\n    def from_name(\n        cls, name: str, css_map: Optional[dict[str, str]] = None\n    ) -&gt; \"CSSColor\":\n        \"\"\"Create a CSSColor instance from a color name.\"\"\"\n        if not name:\n            raise ValueError(\"Name must be a non-empty string.\")\n        css_map = css_map or get_css_map()\n        norm = _normalize_name(name)\n        log.debug(f\"Creating CSSColor from name: name={norm!r}\")\n        hex_value = css_map.get(norm)\n        if not hex_value:\n            raise ValueError(f\"Unknown color name: {name}\")\n        red, green, blue = cls.hex_to_rgb(hex_value)\n        return cls(name=norm, hex=hex_value, red=red, green=green, blue=blue)\n\n    @classmethod\n    def from_hex(cls, hex: str, css_map: Optional[dict[str, str]] = None) -&gt; \"CSSColor\":  # pylint:disable=W0622\n        \"\"\"Create a CSSColor instance from a hex value.\"\"\"\n        if not hex:\n            raise ValueError(\"Hex value must be a non-empty string.\")\n        css_map = css_map or get_css_map() or get_css_map()\n        norm_hex = _normalize_hex(hex)\n        name = _find_name_by_hex(norm_hex, css_map)\n        if name is None:\n            raise ValueError(f\"Unknown hex value: {hex}\")\n        red, green, blue = cls.hex_to_rgb(norm_hex)\n        return cls(name=name, hex=norm_hex, red=red, green=green, blue=blue)\n\n    @classmethod\n    def from_rgb(\n        cls,\n        red: int,\n        green: int,\n        blue: int,\n        css_map: Optional[dict[str, str]] = None,\n    ) -&gt; \"CSSColor\":\n        \"\"\"Create a CSSColor instance from RGB values.\"\"\"\n        for channel, label in ((red, \"red\"), (green, \"green\"), (blue, \"blue\")):\n            if not 0 &lt;= channel &lt;= 255:\n                raise ValueError(\n                    f\"{label.capitalize()} value must be between 0 and 255.\"\n                )\n        css_map = css_map or get_css_map() or get_css_map()\n        hex_str = _hex_from_rgb(red, green, blue)\n        name = _find_name_by_hex(hex_str, css_map)\n        if name is None:\n            raise ValueError(f\"Unknown RGB values: ({red}, {green}, {blue})\")\n        return cls(name=name, hex=hex_str, red=red, green=green, blue=blue)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the name of the color.\n        Returns:\n            str: The name of the color.\"\"\"\n        return f\"{self.name}\"\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"CSSColor(name={self.name}, hex={self.hex}, \"\n            f\"rgb=({self.red}, {self.green}, {self.blue}))\"\n        )\n\n    @staticmethod\n    def hex_to_rgb(hex_str: str) -&gt; Tuple[int, int, int]:\n        \"\"\"Return the RGB components as a tuple.\n        Returns:\n            Tuple[int, int, int]: The RGB components.\n        \"\"\"\n        log.debug(f\"Converting hex to RGB: hex_str={hex_str!r}\")\n        norm = _normalize_hex(hex_str)\n        val = norm.lstrip(\"#\")\n        red, green, blue = (int(val[i : i + 2], 16) for i in (0, 2, 4))\n        log.debug(f\"Converted hex {norm} to RGB: red={red}, green={green}, blue={blue}\")\n        return (red, green, blue)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the color.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        \"\"\"Set the name of the color.\"\"\"\n        log.debug(f\"Setting name to: {value!r}\")\n        self._name = _normalize_name(value)\n        if self._name in get_css_map() and not self._hex:\n            self.hex = get_css_map()[self._name]\n            log.debug(f\"Set hex from name: {self.hex=}\")\n        if self._hex and any(v &lt; 0 for v in (self._red, self._green, self._blue)):\n            red, green, blue = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = red, green, blue\n            log.debug(f\"Set RGB from hex: {self._red=}, {self._green=}, {self._blue=}\")\n\n    @property\n    def hex(self) -&gt; str:\n        \"\"\"Return the hex representation of the color.\"\"\"\n        log.debug(f\"Getting hex: {self._hex=}\")\n        return self._hex\n\n    @hex.setter\n    def hex(self, value: str) -&gt; None:\n        \"\"\"Set the hex representation of the color.\"\"\"\n        log.debug(f\"Setting hex to: {value!r}\")\n        self._hex = _normalize_hex(value)\n        if any(v &lt; 0 for v in (self._red, self._green, self._blue)):\n            red, green, blue = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = red, green, blue\n        if not self._name:\n            css_map = get_css_map() or get_css_map()\n            name = _find_name_by_hex(self._hex, css_map)\n            if name:\n                self._name = name\n\n    @property\n    def red(self) -&gt; int:\n        \"\"\"Return the red component of the color.\"\"\"\n        log.debug(f\"Getting red: {self._red=}\")\n        return self._red\n\n    @red.setter\n    def red(self, value: int) -&gt; None:\n        \"\"\"Set the red component of the color.\"\"\"\n        log.debug(f\"Setting red to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._red = value\n        else:\n            raise ValueError(\"Red value must be between 0 and 255.\")\n        if self._green &gt;= 0 and self._blue &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    @property\n    def green(self) -&gt; int:\n        \"\"\"Return the green component of the color.\"\"\"\n        log.debug(f\"Getting green: {self._green=}\")\n        return self._green\n\n    @green.setter\n    def green(self, value: int) -&gt; None:\n        \"\"\"Set the green component of the color.\"\"\"\n        log.debug(f\"Setting green to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._green = value\n        else:\n            raise ValueError(\"Green value must be between 0 and 255.\")\n        if self._red &gt;= 0 and self._blue &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    @property\n    def blue(self) -&gt; int:\n        \"\"\"Return the blue component of the color.\"\"\"\n        log.debug(f\"Getting blue: {self._blue=}\")\n        return self._blue\n\n    @blue.setter\n    def blue(self, value: int) -&gt; None:\n        \"\"\"Set the blue component of the color.\"\"\"\n        log.debug(f\"Setting blue to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._blue = value\n        else:\n            raise ValueError(\"Blue value must be between 0 and 255.\")\n        if self._red &gt;= 0 and self._green &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    def rich(self, reverse: bool = False) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the color.\"\"\"\n        class_style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n        color_style = f\"bold on {self.hex}\" if reverse else f\"bold {self.hex}\"\n        label_style = f\"bold black on {self.hex}\" if reverse else \"bold white\"\n        return Text.assemble(*[\n            Text(\"CSSColor\", style=class_style),\n            Text(\"&lt;\", style=color_style),\n            Text(\"hex=\", style=label_style),\n            Text(f\"'{self.hex}'\", style=color_style),\n            Text(\", rgb='\", style=label_style),\n            self.rgb(reverse),\n            Text(\", name=\", style=label_style),\n            Text(f\"{self.name!r}'\", style=color_style),\n            Text(\"&gt;\", style=color_style),\n        ])\n\n    def __rich__(self) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the color.\"\"\"\n        return self.rich()\n\n    def rgb(self, reverse: bool = False) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the RGB values.\"\"\"\n        style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n        red_style = \"bold #AA0000\" if not reverse else f\"bold #AA0000 on {self.hex}\"\n        green_style = \"bold #00AA00\" if not reverse else f\"bold #00AA00 on {self.hex}\"\n        blue_style = \"bold #00AAFF\" if not reverse else f\"bold #00AAFF on {self.hex}\"\n\n        rgb = Text.assemble(*[\n            Text(\"rgb(\", style=style),\n            Text(f\"{self.red}\", style=red_style),\n            Text(\",\", style=style),\n            Text(f\"{self.green}\", style=green_style),\n            Text(\",\", style=style),\n            Text(f\"{self.blue}\", style=blue_style),\n            Text(\")\", style=style),\n        ])\n        return rgb\n\n    def panel(self) -&gt; Panel:\n        \"\"\"Return a Rich Table representation of the color.\"\"\"\n        table = Table(\n            show_header=False,\n            show_edge=False,\n            show_lines=False,\n            pad_edge=True,\n            collapse_padding=False,\n            border_style=f\"bold {self.hex}\",\n        )\n\n        table.add_column(\"Hex\")\n        table.add_column(\"RGB\")\n        table.add_row(\n            Text(self.hex, style=f\"bold {self.hex}\"), Align(self.rgb(), align=\"center\")\n        )\n        return Panel(\n            table,\n            title=f\"[bold on {self.hex}] {self.name.capitalize()} [/bold on {self.hex}]\",\n            border_style=f\"bold {self.hex}\",\n            expand=False,\n            padding=(1, 4),\n        )\n\n    @property\n    def triplet(self) -&gt; ColorTriplet:\n        \"\"\"Return the RGB triplet for this color.\"\"\"\n        return ColorTriplet(self.red, self.green, self.blue)\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.blue","title":"<code>blue</code>  <code>property</code> <code>writable</code>","text":"<p>Return the blue component of the color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.green","title":"<code>green</code>  <code>property</code> <code>writable</code>","text":"<p>Return the green component of the color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.hex","title":"<code>hex</code>  <code>property</code> <code>writable</code>","text":"<p>Return the hex representation of the color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Return the name of the color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.red","title":"<code>red</code>  <code>property</code> <code>writable</code>","text":"<p>Return the red component of the color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.triplet","title":"<code>triplet</code>  <code>property</code>","text":"<p>Return the RGB triplet for this color.</p>"},{"location":"reference/#rich_color_ext.CSSColor.__init__","title":"<code>__init__(name=None, hex=None, red=None, green=None, blue=None)</code>","text":"<p>Create a CSSColor.</p> <p>You may provide any combination of name/hex/RGB sufficient to derive the remaining attributes. Values are normalised and validated.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    hex: Optional[str] = None,  # pylint:disable=W0622\n    red: Optional[int] = None,\n    green: Optional[int] = None,\n    blue: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Create a CSSColor.\n\n    You may provide any combination of name/hex/RGB sufficient to derive the\n    remaining attributes. Values are normalised and validated.\n    \"\"\"\n    log.debug(f\"Creating CSSColor({name=}, {hex=}, {red=}, {green=}, {blue=})\")\n\n    self._name = \"\"\n    self._hex = \"\"\n    self._red = -1\n    self._green = -1\n    self._blue = -1\n\n    # Apply provided values through property setters to keep invariants.\n    if name is not None:\n        self.name = name\n    if hex is not None:\n        self.hex = hex\n    # Only set numeric channels if caller provided them (None means omitted)\n    if red is not None:\n        self.red = red\n    if green is not None:\n        self.green = green\n    if blue is not None:\n        self.blue = blue\n\n    # Fill missing values when possible\n    if self._name and not self._hex and self._name in get_css_map():\n        self.hex = get_css_map()[self._name]\n\n    if self._hex and (self._red &lt; 0 or self._green &lt; 0 or self._blue &lt; 0):\n        r, g, b = self.hex_to_rgb(self._hex)\n        self._red, self._green, self._blue = r, g, b\n\n    if not self._name and self._hex:\n        css_map = get_css_map() or get_css_map()\n        derived = _find_name_by_hex(self._hex, css_map)\n        if derived:\n            self._name = derived\n\n    # Final validation\n    if (\n        not self._name\n        or not self._hex\n        or any(v &lt; 0 or v &gt; 255 for v in (self._red, self._green, self._blue))\n    ):\n        raise ValueError(\"Unable to determine color.\")\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.__rich__","title":"<code>__rich__()</code>","text":"<p>Return a Rich Text representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __rich__(self) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the color.\"\"\"\n    return self.rich()\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the color. Returns:     str: The name of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the name of the color.\n    Returns:\n        str: The name of the color.\"\"\"\n    return f\"{self.name}\"\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.from_hex","title":"<code>from_hex(hex, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from a hex value.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex: str, css_map: Optional[dict[str, str]] = None) -&gt; \"CSSColor\":  # pylint:disable=W0622\n    \"\"\"Create a CSSColor instance from a hex value.\"\"\"\n    if not hex:\n        raise ValueError(\"Hex value must be a non-empty string.\")\n    css_map = css_map or get_css_map() or get_css_map()\n    norm_hex = _normalize_hex(hex)\n    name = _find_name_by_hex(norm_hex, css_map)\n    if name is None:\n        raise ValueError(f\"Unknown hex value: {hex}\")\n    red, green, blue = cls.hex_to_rgb(norm_hex)\n    return cls(name=name, hex=norm_hex, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.from_name","title":"<code>from_name(name, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from a color name.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_name(\n    cls, name: str, css_map: Optional[dict[str, str]] = None\n) -&gt; \"CSSColor\":\n    \"\"\"Create a CSSColor instance from a color name.\"\"\"\n    if not name:\n        raise ValueError(\"Name must be a non-empty string.\")\n    css_map = css_map or get_css_map()\n    norm = _normalize_name(name)\n    log.debug(f\"Creating CSSColor from name: name={norm!r}\")\n    hex_value = css_map.get(norm)\n    if not hex_value:\n        raise ValueError(f\"Unknown color name: {name}\")\n    red, green, blue = cls.hex_to_rgb(hex_value)\n    return cls(name=norm, hex=hex_value, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.from_rgb","title":"<code>from_rgb(red, green, blue, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from RGB values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_rgb(\n    cls,\n    red: int,\n    green: int,\n    blue: int,\n    css_map: Optional[dict[str, str]] = None,\n) -&gt; \"CSSColor\":\n    \"\"\"Create a CSSColor instance from RGB values.\"\"\"\n    for channel, label in ((red, \"red\"), (green, \"green\"), (blue, \"blue\")):\n        if not 0 &lt;= channel &lt;= 255:\n            raise ValueError(\n                f\"{label.capitalize()} value must be between 0 and 255.\"\n            )\n    css_map = css_map or get_css_map() or get_css_map()\n    hex_str = _hex_from_rgb(red, green, blue)\n    name = _find_name_by_hex(hex_str, css_map)\n    if name is None:\n        raise ValueError(f\"Unknown RGB values: ({red}, {green}, {blue})\")\n    return cls(name=name, hex=hex_str, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.hex_to_rgb","title":"<code>hex_to_rgb(hex_str)</code>  <code>staticmethod</code>","text":"<p>Return the RGB components as a tuple. Returns:     Tuple[int, int, int]: The RGB components.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@staticmethod\ndef hex_to_rgb(hex_str: str) -&gt; Tuple[int, int, int]:\n    \"\"\"Return the RGB components as a tuple.\n    Returns:\n        Tuple[int, int, int]: The RGB components.\n    \"\"\"\n    log.debug(f\"Converting hex to RGB: hex_str={hex_str!r}\")\n    norm = _normalize_hex(hex_str)\n    val = norm.lstrip(\"#\")\n    red, green, blue = (int(val[i : i + 2], 16) for i in (0, 2, 4))\n    log.debug(f\"Converted hex {norm} to RGB: red={red}, green={green}, blue={blue}\")\n    return (red, green, blue)\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.panel","title":"<code>panel()</code>","text":"<p>Return a Rich Table representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def panel(self) -&gt; Panel:\n    \"\"\"Return a Rich Table representation of the color.\"\"\"\n    table = Table(\n        show_header=False,\n        show_edge=False,\n        show_lines=False,\n        pad_edge=True,\n        collapse_padding=False,\n        border_style=f\"bold {self.hex}\",\n    )\n\n    table.add_column(\"Hex\")\n    table.add_column(\"RGB\")\n    table.add_row(\n        Text(self.hex, style=f\"bold {self.hex}\"), Align(self.rgb(), align=\"center\")\n    )\n    return Panel(\n        table,\n        title=f\"[bold on {self.hex}] {self.name.capitalize()} [/bold on {self.hex}]\",\n        border_style=f\"bold {self.hex}\",\n        expand=False,\n        padding=(1, 4),\n    )\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.rgb","title":"<code>rgb(reverse=False)</code>","text":"<p>Return a Rich Text representation of the RGB values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def rgb(self, reverse: bool = False) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the RGB values.\"\"\"\n    style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n    red_style = \"bold #AA0000\" if not reverse else f\"bold #AA0000 on {self.hex}\"\n    green_style = \"bold #00AA00\" if not reverse else f\"bold #00AA00 on {self.hex}\"\n    blue_style = \"bold #00AAFF\" if not reverse else f\"bold #00AAFF on {self.hex}\"\n\n    rgb = Text.assemble(*[\n        Text(\"rgb(\", style=style),\n        Text(f\"{self.red}\", style=red_style),\n        Text(\",\", style=style),\n        Text(f\"{self.green}\", style=green_style),\n        Text(\",\", style=style),\n        Text(f\"{self.blue}\", style=blue_style),\n        Text(\")\", style=style),\n    ])\n    return rgb\n</code></pre>"},{"location":"reference/#rich_color_ext.CSSColor.rich","title":"<code>rich(reverse=False)</code>","text":"<p>Return a Rich Text representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def rich(self, reverse: bool = False) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the color.\"\"\"\n    class_style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n    color_style = f\"bold on {self.hex}\" if reverse else f\"bold {self.hex}\"\n    label_style = f\"bold black on {self.hex}\" if reverse else \"bold white\"\n    return Text.assemble(*[\n        Text(\"CSSColor\", style=class_style),\n        Text(\"&lt;\", style=color_style),\n        Text(\"hex=\", style=label_style),\n        Text(f\"'{self.hex}'\", style=color_style),\n        Text(\", rgb='\", style=label_style),\n        self.rgb(reverse),\n        Text(\", name=\", style=label_style),\n        Text(f\"{self.name!r}'\", style=color_style),\n        Text(\"&gt;\", style=color_style),\n    ])\n</code></pre>"},{"location":"reference/#rich_color_ext.get_css_map","title":"<code>get_css_map()</code>  <code>cached</code>","text":"<p>Return the mapping of CSS colour name (lowercase) \u2192 hex string (\u2018#RRGGBB\u2019). Loads the data on first call.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping colour name to hex.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@lru_cache(maxsize=1024)\ndef get_css_map() -&gt; dict[str, str]:\n    \"\"\"\n    Return the mapping of CSS colour name (lowercase) \u2192 hex string (\u2018#RRGGBB\u2019).\n    Loads the data on first call.\n\n    Returns:\n        Dict mapping colour name to hex.\n    \"\"\"\n    css_map = {\n        \"aliceblue\": \"#f0f8ff\",\n        \"antiquewhite\": \"#faebd7\",\n        \"aqua\": \"#00ffff\",\n        \"aquamarine\": \"#7fffd4\",\n        \"azure\": \"#f0ffff\",\n        \"beige\": \"#f5f5dc\",\n        \"bisque\": \"#ffe4c4\",\n        \"black\": \"#000000\",\n        \"blanchedalmond\": \"#ffebcd\",\n        \"blue\": \"#0000ff\",\n        \"blueviolet\": \"#8a2be2\",\n        \"brown\": \"#a52a2a\",\n        \"burlywood\": \"#deb887\",\n        \"cadetblue\": \"#5f9ea0\",\n        \"chartreuse\": \"#7fff00\",\n        \"chocolate\": \"#d2691e\",\n        \"coral\": \"#ff7f50\",\n        \"cornflowerblue\": \"#6495ed\",\n        \"cornsilk\": \"#fff8dc\",\n        \"crimson\": \"#dc143c\",\n        \"cyan\": \"#00ffff\",\n        \"darkblue\": \"#00008b\",\n        \"darkcyan\": \"#008b8b\",\n        \"darkgoldenrod\": \"#b8860b\",\n        \"darkgray\": \"#a9a9a9\",\n        \"darkgreen\": \"#006400\",\n        \"darkgrey\": \"#a9a9a9\",\n        \"darkkhaki\": \"#bdb76b\",\n        \"darkmagenta\": \"#8b008b\",\n        \"darkolivegreen\": \"#556b2f\",\n        \"darkorange\": \"#ff8c00\",\n        \"darkorchid\": \"#9932cc\",\n        \"darkred\": \"#8b0000\",\n        \"darksalmon\": \"#e9967a\",\n        \"darkseagreen\": \"#8fbc8f\",\n        \"darkslateblue\": \"#483d8b\",\n        \"darkslategray\": \"#2f4f4f\",\n        \"darkslategrey\": \"#2f4f4f\",\n        \"darkturquoise\": \"#00ced1\",\n        \"darkviolet\": \"#9400d3\",\n        \"deeppink\": \"#ff1493\",\n        \"deepskyblue\": \"#00bfff\",\n        \"dimgray\": \"#696969\",\n        \"dimgrey\": \"#696969\",\n        \"dodgerblue\": \"#1e90ff\",\n        \"firebrick\": \"#b22222\",\n        \"floralwhite\": \"#fffaf0\",\n        \"forestgreen\": \"#228b22\",\n        \"fuchsia\": \"#ff00ff\",\n        \"gainsboro\": \"#dcdcdc\",\n        \"ghostwhite\": \"#f8f8ff\",\n        \"gold\": \"#ffd700\",\n        \"goldenrod\": \"#daa520\",\n        \"gray\": \"#808080\",\n        \"green\": \"#008000\",\n        \"greenyellow\": \"#adff2f\",\n        \"grey\": \"#808080\",\n        \"honeydew\": \"#f0fff0\",\n        \"hotpink\": \"#ff69b4\",\n        \"indianred\": \"#cd5c5c\",\n        \"indigo\": \"#4b0082\",\n        \"ivory\": \"#fffff0\",\n        \"khaki\": \"#f0e68c\",\n        \"lavender\": \"#e6e6fa\",\n        \"lavenderblush\": \"#fff0f5\",\n        \"lawngreen\": \"#7cfc00\",\n        \"lemonchiffon\": \"#fffacd\",\n        \"lightblue\": \"#add8e6\",\n        \"lightcoral\": \"#f08080\",\n        \"lightcyan\": \"#e0ffff\",\n        \"lightgoldenrodyellow\": \"#fafad2\",\n        \"lightgray\": \"#d3d3d3\",\n        \"lightgreen\": \"#90ee90\",\n        \"lightgrey\": \"#d3d3d3\",\n        \"lightpink\": \"#ffb6c1\",\n        \"lightsalmon\": \"#ffa07a\",\n        \"lightseagreen\": \"#20b2aa\",\n        \"lightskyblue\": \"#87cefa\",\n        \"lightslategray\": \"#778899\",\n        \"lightslategrey\": \"#778899\",\n        \"lightsteelblue\": \"#b0c4de\",\n        \"lightyellow\": \"#ffffe0\",\n        \"lime\": \"#00ff00\",\n        \"limegreen\": \"#32cd32\",\n        \"linen\": \"#faf0e6\",\n        \"magenta\": \"#ff00ff\",\n        \"maroon\": \"#800000\",\n        \"mediumaquamarine\": \"#66cdaa\",\n        \"mediumblue\": \"#0000cd\",\n        \"mediumorchid\": \"#ba55d3\",\n        \"mediumpurple\": \"#9370db\",\n        \"mediumseagreen\": \"#3cb371\",\n        \"mediumslateblue\": \"#7b68ee\",\n        \"mediumspringgreen\": \"#00fa9a\",\n        \"mediumturquoise\": \"#48d1cc\",\n        \"mediumvioletred\": \"#c71585\",\n        \"midnightblue\": \"#191970\",\n        \"mintcream\": \"#f5fffa\",\n        \"mistyrose\": \"#ffe4e1\",\n        \"moccasin\": \"#ffe4b5\",\n        \"navajowhite\": \"#ffdead\",\n        \"navy\": \"#000080\",\n        \"oldlace\": \"#fdf5e6\",\n        \"olive\": \"#808000\",\n        \"olivedrab\": \"#6b8e23\",\n        \"orange\": \"#ffa500\",\n        \"orangered\": \"#ff4500\",\n        \"orchid\": \"#da70d6\",\n        \"palegoldenrod\": \"#eee8aa\",\n        \"palegreen\": \"#98fb98\",\n        \"paleturquoise\": \"#afeeee\",\n        \"palevioletred\": \"#db7093\",\n        \"papayawhip\": \"#ffefd5\",\n        \"peachpuff\": \"#ffdab9\",\n        \"peru\": \"#cd853f\",\n        \"pink\": \"#ffc0cb\",\n        \"plum\": \"#dda0dd\",\n        \"powderblue\": \"#b0e0e6\",\n        \"purple\": \"#800080\",\n        \"rebeccapurple\": \"#663399\",\n        \"red\": \"#ff0000\",\n        \"rosybrown\": \"#bc8f8f\",\n        \"royalblue\": \"#4169e1\",\n        \"saddlebrown\": \"#8b4513\",\n        \"salmon\": \"#fa8072\",\n        \"sandybrown\": \"#f4a460\",\n        \"seagreen\": \"#2e8b57\",\n        \"seashell\": \"#fff5ee\",\n        \"sienna\": \"#a0522d\",\n        \"silver\": \"#c0c0c0\",\n        \"skyblue\": \"#87ceeb\",\n        \"slateblue\": \"#6a5acd\",\n        \"slategray\": \"#708090\",\n        \"slategrey\": \"#708090\",\n        \"snow\": \"#fffafa\",\n        \"springgreen\": \"#00ff7f\",\n        \"steelblue\": \"#4682b4\",\n        \"tan\": \"#d2b48c\",\n        \"teal\": \"#008080\",\n        \"thistle\": \"#d8bfd8\",\n        \"tomato\": \"#ff6347\",\n        \"turquoise\": \"#40e0d0\",\n        \"violet\": \"#ee82ee\",\n        \"wheat\": \"#f5deb3\",\n        \"white\": \"#ffffff\",\n        \"whitesmoke\": \"#f5f5f5\",\n        \"yellow\": \"#ffff00\",\n        \"yellowgreen\": \"#9acd32\",\n    }\n    return css_map\n</code></pre>"},{"location":"reference/#rich_color_ext.install","title":"<code>install()</code>","text":"<p>Install the monkey patch. After this call, rich.color.Color.parse will support 3\u2010digit hex and CSS colour names. Safe to call multiple times.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def install() -&gt; None:\n    \"\"\"\n    Install the monkey patch. After this call, rich.color.Color.parse will\n    support 3\u2010digit hex and CSS colour names. Safe to call multiple times.\n    \"\"\"\n    global INSTALLED  # pylint: disable=global-statement\n    if INSTALLED:\n        return\n    Color.parse = _patched_parse  # type: ignore[assignment]\n    INSTALLED = True\n</code></pre>"},{"location":"reference/#rich_color_ext.is_installed","title":"<code>is_installed()</code>","text":"<p>Return True if the monkey patch is currently installed.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def is_installed() -&gt; bool:\n    \"\"\"\n    Return True if the monkey patch is currently installed.\n    \"\"\"\n    return INSTALLED\n</code></pre>"},{"location":"reference/#rich_color_ext.rce_install","title":"<code>rce_install()</code>","text":"<p>Backward-compatible wrapper for install().</p> Source code in <code>src/rich_color_ext/__init__.py</code> <pre><code>def rce_install() -&gt; None:\n    \"\"\"Backward-compatible wrapper for install().\"\"\"\n    install()\n</code></pre>"},{"location":"reference/#rich_color_ext.rce_uninstall","title":"<code>rce_uninstall()</code>","text":"<p>Backward-compatible wrapper for uninstall().</p> Source code in <code>src/rich_color_ext/__init__.py</code> <pre><code>def rce_uninstall() -&gt; None:\n    \"\"\"Backward-compatible wrapper for uninstall().\"\"\"\n    # Call uninstall once. Previous versions mistakenly called it twice.\n    uninstall()\n</code></pre>"},{"location":"reference/#rich_color_ext.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall the monkey patch, restoring the original rich.color.Color.parse. Safe to call multiple times.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def uninstall() -&gt; None:\n    \"\"\"\n    Uninstall the monkey patch, restoring the original rich.color.Color.parse.\n    Safe to call multiple times.\n    \"\"\"\n    global INSTALLED  # pylint: disable=global-statement\n    if not INSTALLED:\n        return\n    Color.parse = _ORIGINAL_PARSE  # type: ignore[assignment]\n    INSTALLED = False\n</code></pre>"},{"location":"reference/cli_logger/","title":"CLI & Logger","text":"<p>Command-line interface for rich-color-ext.</p> <p>Provides a tiny CLI to inspect CSS colors and to (un)install the runtime patch that extends Rich's color parsing.</p> <p>A Rich-based loguru logger sink.</p>"},{"location":"reference/cli_logger/#rich_color_ext.cli.get_css_color_map","title":"<code>get_css_color_map()</code>  <code>cached</code>","text":"<p>Return CSS color mapping with compatibility fallback.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>@lru_cache(maxsize=1024)\ndef get_css_color_map() -&gt; dict[str, str]:\n    \"\"\"Return CSS color mapping with compatibility fallback.\"\"\"\n\n    global _CSS_CACHE  # pylint: disable=global-statement\n    if _CSS_CACHE is not None:\n        return _CSS_CACHE\n\n    # Prefer a package-level loader if present (newer layout exposes get_css_map\n    # on the package itself).\n    pkg_loader = getattr(_pkg, \"get_css_map\", None)\n    if callable(pkg_loader):\n        try:\n            result = pkg_loader()\n            if isinstance(result, dict):\n                _CSS_CACHE = {str(k).lower(): str(v) for k, v in result.items()}\n            else:\n                _CSS_CACHE = {}\n            return _CSS_CACHE\n        except (TypeError, ValueError, AttributeError, KeyError):\n            # fall through to other loaders\n            pass\n    css_mod: ModuleType | None\n    try:\n        css_mod = importlib.import_module(\"rich_color_ext._css_colors\")\n    except ModuleNotFoundError:  # pragma: no cover - legacy distribution fallback\n        css_mod = None\n    if css_mod is not None:\n        loader = None\n        for attr in (\"get_css_color_map\", \"get_css_map\"):\n            candidate = getattr(css_mod, attr, None)\n            if callable(candidate):\n                loader = candidate\n                break\n        if loader is not None:\n            result = loader()\n            normalized: dict[str, str] = {}\n            if isinstance(result, dict):\n                normalized = {str(k).lower(): str(v) for k, v in result.items()}\n            else:\n                items = getattr(result, \"items\", None)\n                if callable(items):\n                    for key, value in items():  # type: ignore[call-arg]\n                        normalized[str(key).lower()] = str(value)\n            _CSS_CACHE = normalized\n            return _CSS_CACHE\n    try:\n        raw = (\n            importlib.resources.files(\"rich_color_ext\")\n            .joinpath(\"colors.json\")\n            .read_text(encoding=\"utf-8\")\n        )\n    except (FileNotFoundError, ModuleNotFoundError):\n        _CSS_CACHE = {}\n        return _CSS_CACHE\n    try:\n        data = json.loads(raw)\n    except json.JSONDecodeError:\n        _CSS_CACHE = {}\n        return _CSS_CACHE\n    if isinstance(data, dict):\n        _CSS_CACHE = {str(k).lower(): str(v) for k, v in data.items()}\n        return _CSS_CACHE\n    if isinstance(data, list):\n        mapped: dict[str, str] = {}\n        for item in data:\n            if isinstance(item, dict):\n                name = item.get(\"name\") or item.get(\"color\")\n                value = item.get(\"hex\") or item.get(\"value\")\n                if isinstance(name, str) and isinstance(value, str):\n                    mapped[name.lower()] = value\n        _CSS_CACHE = mapped\n        return _CSS_CACHE\n    _CSS_CACHE = {}\n    return _CSS_CACHE\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.cli.install_panel","title":"<code>install_panel()</code>","text":"<p>Print installation message panel.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>def install_panel() -&gt; Panel:\n    \"\"\"Print installation message panel.\"\"\"\n    return Panel(\n        \"rich-color-ext [b i #99ff00]installed![/]\",\n        title=\"[#ffffff]rich-color-ext[/]\",\n        subtitle=\"[dim #00ff00]Success[/]\",\n        border_style=\"bold #008800\",\n        expand=False,\n        subtitle_align=\"right\",\n        padding=(1, 4),\n    )\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.cli.list_colors","title":"<code>list_colors()</code>","text":"<p>List all available CSS color names.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>def list_colors() -&gt; Iterable[str]:\n    \"\"\"List all available CSS color names.\"\"\"\n    css_map = get_css_color_map()\n    return sorted(css_map.keys())\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.cli.main","title":"<code>main(argv=None)</code>","text":"<p>Main entry point for the CLI.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>list[str] | None</code> <p>Command-line arguments (default: None, uses sys.argv).</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit status code.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>def main(argv: list[str] | None = None) -&gt; int:\n    \"\"\"Main entry point for the CLI.\n\n    Args:\n        argv: Command-line arguments (default: None, uses sys.argv).\n\n    Returns:\n        Exit status code.\n    \"\"\"\n    parser = argparse.ArgumentParser(prog=\"rich-color-ext\")\n    parser.add_argument(\"--version\", action=\"store_true\", help=\"Print version and exit\")\n    sub = parser.add_subparsers(dest=\"command\")\n\n    sub.add_parser(\"install\", help=\"Patch Rich to use the extended color parser\")\n    sub.add_parser(\"uninstall\", help=\"Restore Rich's original color parser\")\n\n    ls = sub.add_parser(\"list\", help=\"List available CSS color names\")\n    ls.add_argument(\n        \"--limit\", type=int, default=0, help=\"Limit number of names printed\"\n    )\n    ls.add_argument(\"--pretty\", action=\"store_true\", help=\"Show a pretty table\")\n\n    search = sub.add_parser(\"search\", help=\"Search CSS color names by substring\")\n    search.add_argument(\"query\", help=\"Substring to search for (case-insensitive)\")\n    search.add_argument(\n        \"--limit\", type=int, default=0, help=\"Limit number of names printed\"\n    )\n    search.add_argument(\"--pretty\", action=\"store_true\", help=\"Show a pretty table\")\n\n    show = sub.add_parser(\"show\", help=\"Show hex and RGB for a CSS color name\")\n    show.add_argument(\"name\", help=\"CSS color name to show\")\n\n    args = parser.parse_args(argv)\n    console = Console()\n\n    if args.version:\n        console.print(\n            f\"\\n[bold #99ff00]rich-color-ext[/] [bold #00ffff]v{__version__}[/]\"\n        )\n        return 0\n\n    if args.command == \"install\":\n        install()\n        console.print(install_panel())\n        return 0\n\n    if args.command == \"uninstall\":\n        uninstall()\n        console.print(uninstall_panel())\n        return 0\n\n    if args.command == \"list\":\n        if not is_installed():\n            install()\n            console.print(install_panel())\n        names = list_colors()\n        if args.limit and args.limit &gt; 0:\n            names = list(names)[: args.limit]\n        if getattr(args, \"pretty\", False):\n            table = _build_table(names)\n            console.print(table)\n        else:\n            console.print(\"[d i]Listing available CSS color names...[/]\")\n            console.print(\", \".join([f\"[b {n}]{n}[/]\" for n in names]))\n        return 0\n\n    if args.command == \"search\":\n        q = args.query.lower()\n        all_names = list_colors()\n        matches = [n for n in all_names if q in n.lower()]\n        if args.limit and args.limit &gt; 0:\n            matches = matches[: args.limit]\n        if getattr(args, \"pretty\", False):\n            table = _build_table(matches)\n            console.print(table)\n        else:\n            for n in matches:\n                console.print(n)\n        return 0\n\n    if args.command == \"show\":\n        try:\n            panel = show_color(args.name)\n        except KeyError:\n            console.print(f\"Unknown color: {args.name}\")\n            return 2\n        console.print(panel)\n        return 0\n\n    parser.print_help()\n    return 1\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.cli.show_color","title":"<code>show_color(name)</code>","text":"<p>Show hex and RGB for a given CSS color name.</p> <p>Returns a Rich Panel object for pretty printing.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>def show_color(name: str) -&gt; Panel:\n    \"\"\"Show hex and RGB for a given CSS color name.\n\n    Returns a Rich Panel object for pretty printing.\n    \"\"\"\n    color = CSSColor.from_name(name)\n    return color.panel()\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.cli.uninstall_panel","title":"<code>uninstall_panel()</code>","text":"<p>Print uninstallation message panel.</p> Source code in <code>src/rich_color_ext/cli.py</code> <pre><code>def uninstall_panel() -&gt; Panel:\n    \"\"\"Print uninstallation message panel.\"\"\"\n    return Panel(\n        \"rich-color-ext [b i #ff0099]uninstalled![/]\",\n        title=\"[#ffffff]rich-color-ext[/]\",\n        subtitle=\"[dim #ff0000]Restored[/]\",\n        border_style=\"bold #880000\",\n        expand=False,\n        subtitle_align=\"right\",\n        padding=(1, 4),\n    )\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.logger.get_logger","title":"<code>get_logger()</code>","text":"<p>Get the configured loguru logger.</p> Source code in <code>src/rich_color_ext/logger.py</code> <pre><code>def get_logger():\n    \"\"\"Get the configured loguru logger.\"\"\"\n    return log\n</code></pre>"},{"location":"reference/cli_logger/#rich_color_ext.logger.rich_sink","title":"<code>rich_sink(msg)</code>","text":"<p>A Rich-based loguru sink.</p> Source code in <code>src/rich_color_ext/logger.py</code> <pre><code>def rich_sink(msg):\n    \"\"\"A Rich-based loguru sink.\"\"\"\n    record = msg.record\n    # inspect(record, all=True, console=console, private=True, dunder=True)\n    level_name = record[\"level\"].name\n    level_icon = record[\"level\"].icon\n    file = record[\"file\"].name\n    line = record[\"line\"]\n    line_str = f\"Line {line}\"\n    left_pad = \" \" * LEVEL_STYLES[level_name].get(\"left\", 0)\n    right_pad = \" \" * LEVEL_STYLES[level_name].get(\"right\", 0)\n    title_str = f\"{level_icon} {left_pad}{level_name}{right_pad} \\\n {level_icon}  {file:&gt;12}:{line_str:9}\"\n    title_text = Text(title_str, style=LEVEL_STYLES[level_name][\"title\"])\n    msg_str = str(record[\"message\"])\n    msg_text = Text(msg_str, style=LEVEL_STYLES[level_name][\"text\"])\n    console.print(\n        Panel(\n            msg_text,\n            title=title_text,\n            title_align=\"left\",\n            border_style=LEVEL_STYLES[level_name][\"border\"],\n            padding=(1, 2),\n        )\n    )\n</code></pre>"},{"location":"reference/css/","title":"CSS module","text":""},{"location":"reference/css/#examples","title":"Examples","text":"<p>Create a <code>CSSColor</code> from a hex value or name and inspect its attributes:</p> <pre><code>from rich_color_ext.css import CSSColor\n\ncolor = CSSColor.from_hex('#663399')\nassert color.name == 'rebeccapurple'\nassert color.hex == '#663399'\nassert (color.red, color.green, color.blue) == (102, 51, 153)\n\ncolor2 = CSSColor.from_name('aliceblue')\nassert color2.hex == '#F0F8FF'\n</code></pre> <p>You can also convert hex to RGB directly:</p> <pre><code>from rich_color_ext.css import CSSColor\nassert CSSColor.hex_to_rgb('#ff0000') == (255, 0, 0)\n</code></pre>"},{"location":"reference/css/#api-reference","title":"API reference","text":"<p>CSS color utilities and rich renderables.</p> <p>This module provides a small convenience wrapper, :class:<code>CSSColor</code>, for working with CSS colour names and their hex/RGB representations, along with helpers to iterate all known colours. Data comes from <code>_css_colors.get_css_map</code>.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor","title":"<code>CSSColor</code>","text":"<p>Class to handle CSS color names and their corresponding hex values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>class CSSColor:\n    \"\"\"Class to handle CSS color names and their corresponding hex values.\"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        hex: Optional[str] = None,  # pylint:disable=W0622\n        red: Optional[int] = None,\n        green: Optional[int] = None,\n        blue: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Create a CSSColor.\n\n        You may provide any combination of name/hex/RGB sufficient to derive the\n        remaining attributes. Values are normalised and validated.\n        \"\"\"\n        log.debug(f\"Creating CSSColor({name=}, {hex=}, {red=}, {green=}, {blue=})\")\n\n        self._name = \"\"\n        self._hex = \"\"\n        self._red = -1\n        self._green = -1\n        self._blue = -1\n\n        # Apply provided values through property setters to keep invariants.\n        if name is not None:\n            self.name = name\n        if hex is not None:\n            self.hex = hex\n        # Only set numeric channels if caller provided them (None means omitted)\n        if red is not None:\n            self.red = red\n        if green is not None:\n            self.green = green\n        if blue is not None:\n            self.blue = blue\n\n        # Fill missing values when possible\n        if self._name and not self._hex and self._name in get_css_map():\n            self.hex = get_css_map()[self._name]\n\n        if self._hex and (self._red &lt; 0 or self._green &lt; 0 or self._blue &lt; 0):\n            r, g, b = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = r, g, b\n\n        if not self._name and self._hex:\n            css_map = get_css_map() or get_css_map()\n            derived = _find_name_by_hex(self._hex, css_map)\n            if derived:\n                self._name = derived\n\n        # Final validation\n        if (\n            not self._name\n            or not self._hex\n            or any(v &lt; 0 or v &gt; 255 for v in (self._red, self._green, self._blue))\n        ):\n            raise ValueError(\"Unable to determine color.\")\n\n    @classmethod\n    def from_name(\n        cls, name: str, css_map: Optional[dict[str, str]] = None\n    ) -&gt; \"CSSColor\":\n        \"\"\"Create a CSSColor instance from a color name.\"\"\"\n        if not name:\n            raise ValueError(\"Name must be a non-empty string.\")\n        css_map = css_map or get_css_map()\n        norm = _normalize_name(name)\n        log.debug(f\"Creating CSSColor from name: name={norm!r}\")\n        hex_value = css_map.get(norm)\n        if not hex_value:\n            raise ValueError(f\"Unknown color name: {name}\")\n        red, green, blue = cls.hex_to_rgb(hex_value)\n        return cls(name=norm, hex=hex_value, red=red, green=green, blue=blue)\n\n    @classmethod\n    def from_hex(cls, hex: str, css_map: Optional[dict[str, str]] = None) -&gt; \"CSSColor\":  # pylint:disable=W0622\n        \"\"\"Create a CSSColor instance from a hex value.\"\"\"\n        if not hex:\n            raise ValueError(\"Hex value must be a non-empty string.\")\n        css_map = css_map or get_css_map() or get_css_map()\n        norm_hex = _normalize_hex(hex)\n        name = _find_name_by_hex(norm_hex, css_map)\n        if name is None:\n            raise ValueError(f\"Unknown hex value: {hex}\")\n        red, green, blue = cls.hex_to_rgb(norm_hex)\n        return cls(name=name, hex=norm_hex, red=red, green=green, blue=blue)\n\n    @classmethod\n    def from_rgb(\n        cls,\n        red: int,\n        green: int,\n        blue: int,\n        css_map: Optional[dict[str, str]] = None,\n    ) -&gt; \"CSSColor\":\n        \"\"\"Create a CSSColor instance from RGB values.\"\"\"\n        for channel, label in ((red, \"red\"), (green, \"green\"), (blue, \"blue\")):\n            if not 0 &lt;= channel &lt;= 255:\n                raise ValueError(\n                    f\"{label.capitalize()} value must be between 0 and 255.\"\n                )\n        css_map = css_map or get_css_map() or get_css_map()\n        hex_str = _hex_from_rgb(red, green, blue)\n        name = _find_name_by_hex(hex_str, css_map)\n        if name is None:\n            raise ValueError(f\"Unknown RGB values: ({red}, {green}, {blue})\")\n        return cls(name=name, hex=hex_str, red=red, green=green, blue=blue)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the name of the color.\n        Returns:\n            str: The name of the color.\"\"\"\n        return f\"{self.name}\"\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"CSSColor(name={self.name}, hex={self.hex}, \"\n            f\"rgb=({self.red}, {self.green}, {self.blue}))\"\n        )\n\n    @staticmethod\n    def hex_to_rgb(hex_str: str) -&gt; Tuple[int, int, int]:\n        \"\"\"Return the RGB components as a tuple.\n        Returns:\n            Tuple[int, int, int]: The RGB components.\n        \"\"\"\n        log.debug(f\"Converting hex to RGB: hex_str={hex_str!r}\")\n        norm = _normalize_hex(hex_str)\n        val = norm.lstrip(\"#\")\n        red, green, blue = (int(val[i : i + 2], 16) for i in (0, 2, 4))\n        log.debug(f\"Converted hex {norm} to RGB: red={red}, green={green}, blue={blue}\")\n        return (red, green, blue)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the color.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        \"\"\"Set the name of the color.\"\"\"\n        log.debug(f\"Setting name to: {value!r}\")\n        self._name = _normalize_name(value)\n        if self._name in get_css_map() and not self._hex:\n            self.hex = get_css_map()[self._name]\n            log.debug(f\"Set hex from name: {self.hex=}\")\n        if self._hex and any(v &lt; 0 for v in (self._red, self._green, self._blue)):\n            red, green, blue = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = red, green, blue\n            log.debug(f\"Set RGB from hex: {self._red=}, {self._green=}, {self._blue=}\")\n\n    @property\n    def hex(self) -&gt; str:\n        \"\"\"Return the hex representation of the color.\"\"\"\n        log.debug(f\"Getting hex: {self._hex=}\")\n        return self._hex\n\n    @hex.setter\n    def hex(self, value: str) -&gt; None:\n        \"\"\"Set the hex representation of the color.\"\"\"\n        log.debug(f\"Setting hex to: {value!r}\")\n        self._hex = _normalize_hex(value)\n        if any(v &lt; 0 for v in (self._red, self._green, self._blue)):\n            red, green, blue = self.hex_to_rgb(self._hex)\n            self._red, self._green, self._blue = red, green, blue\n        if not self._name:\n            css_map = get_css_map() or get_css_map()\n            name = _find_name_by_hex(self._hex, css_map)\n            if name:\n                self._name = name\n\n    @property\n    def red(self) -&gt; int:\n        \"\"\"Return the red component of the color.\"\"\"\n        log.debug(f\"Getting red: {self._red=}\")\n        return self._red\n\n    @red.setter\n    def red(self, value: int) -&gt; None:\n        \"\"\"Set the red component of the color.\"\"\"\n        log.debug(f\"Setting red to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._red = value\n        else:\n            raise ValueError(\"Red value must be between 0 and 255.\")\n        if self._green &gt;= 0 and self._blue &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    @property\n    def green(self) -&gt; int:\n        \"\"\"Return the green component of the color.\"\"\"\n        log.debug(f\"Getting green: {self._green=}\")\n        return self._green\n\n    @green.setter\n    def green(self, value: int) -&gt; None:\n        \"\"\"Set the green component of the color.\"\"\"\n        log.debug(f\"Setting green to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._green = value\n        else:\n            raise ValueError(\"Green value must be between 0 and 255.\")\n        if self._red &gt;= 0 and self._blue &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    @property\n    def blue(self) -&gt; int:\n        \"\"\"Return the blue component of the color.\"\"\"\n        log.debug(f\"Getting blue: {self._blue=}\")\n        return self._blue\n\n    @blue.setter\n    def blue(self, value: int) -&gt; None:\n        \"\"\"Set the blue component of the color.\"\"\"\n        log.debug(f\"Setting blue to: {value}\")\n        if 0 &lt;= value &lt;= 255:\n            self._blue = value\n        else:\n            raise ValueError(\"Blue value must be between 0 and 255.\")\n        if self._red &gt;= 0 and self._green &gt;= 0:\n            hex_str = _hex_from_rgb(self._red, self._green, self._blue)\n            self.hex = hex_str\n            if not self._name:\n                css_map = get_css_map() or get_css_map()\n                name = _find_name_by_hex(self._hex, css_map)\n                if name:\n                    self._name = name\n\n    def rich(self, reverse: bool = False) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the color.\"\"\"\n        class_style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n        color_style = f\"bold on {self.hex}\" if reverse else f\"bold {self.hex}\"\n        label_style = f\"bold black on {self.hex}\" if reverse else \"bold white\"\n        return Text.assemble(*[\n            Text(\"CSSColor\", style=class_style),\n            Text(\"&lt;\", style=color_style),\n            Text(\"hex=\", style=label_style),\n            Text(f\"'{self.hex}'\", style=color_style),\n            Text(\", rgb='\", style=label_style),\n            self.rgb(reverse),\n            Text(\", name=\", style=label_style),\n            Text(f\"{self.name!r}'\", style=color_style),\n            Text(\"&gt;\", style=color_style),\n        ])\n\n    def __rich__(self) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the color.\"\"\"\n        return self.rich()\n\n    def rgb(self, reverse: bool = False) -&gt; Text:\n        \"\"\"Return a Rich Text representation of the RGB values.\"\"\"\n        style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n        red_style = \"bold #AA0000\" if not reverse else f\"bold #AA0000 on {self.hex}\"\n        green_style = \"bold #00AA00\" if not reverse else f\"bold #00AA00 on {self.hex}\"\n        blue_style = \"bold #00AAFF\" if not reverse else f\"bold #00AAFF on {self.hex}\"\n\n        rgb = Text.assemble(*[\n            Text(\"rgb(\", style=style),\n            Text(f\"{self.red}\", style=red_style),\n            Text(\",\", style=style),\n            Text(f\"{self.green}\", style=green_style),\n            Text(\",\", style=style),\n            Text(f\"{self.blue}\", style=blue_style),\n            Text(\")\", style=style),\n        ])\n        return rgb\n\n    def panel(self) -&gt; Panel:\n        \"\"\"Return a Rich Table representation of the color.\"\"\"\n        table = Table(\n            show_header=False,\n            show_edge=False,\n            show_lines=False,\n            pad_edge=True,\n            collapse_padding=False,\n            border_style=f\"bold {self.hex}\",\n        )\n\n        table.add_column(\"Hex\")\n        table.add_column(\"RGB\")\n        table.add_row(\n            Text(self.hex, style=f\"bold {self.hex}\"), Align(self.rgb(), align=\"center\")\n        )\n        return Panel(\n            table,\n            title=f\"[bold on {self.hex}] {self.name.capitalize()} [/bold on {self.hex}]\",\n            border_style=f\"bold {self.hex}\",\n            expand=False,\n            padding=(1, 4),\n        )\n\n    @property\n    def triplet(self) -&gt; ColorTriplet:\n        \"\"\"Return the RGB triplet for this color.\"\"\"\n        return ColorTriplet(self.red, self.green, self.blue)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.blue","title":"<code>blue</code>  <code>property</code> <code>writable</code>","text":"<p>Return the blue component of the color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.green","title":"<code>green</code>  <code>property</code> <code>writable</code>","text":"<p>Return the green component of the color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.hex","title":"<code>hex</code>  <code>property</code> <code>writable</code>","text":"<p>Return the hex representation of the color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Return the name of the color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.red","title":"<code>red</code>  <code>property</code> <code>writable</code>","text":"<p>Return the red component of the color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.triplet","title":"<code>triplet</code>  <code>property</code>","text":"<p>Return the RGB triplet for this color.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.__init__","title":"<code>__init__(name=None, hex=None, red=None, green=None, blue=None)</code>","text":"<p>Create a CSSColor.</p> <p>You may provide any combination of name/hex/RGB sufficient to derive the remaining attributes. Values are normalised and validated.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    hex: Optional[str] = None,  # pylint:disable=W0622\n    red: Optional[int] = None,\n    green: Optional[int] = None,\n    blue: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Create a CSSColor.\n\n    You may provide any combination of name/hex/RGB sufficient to derive the\n    remaining attributes. Values are normalised and validated.\n    \"\"\"\n    log.debug(f\"Creating CSSColor({name=}, {hex=}, {red=}, {green=}, {blue=})\")\n\n    self._name = \"\"\n    self._hex = \"\"\n    self._red = -1\n    self._green = -1\n    self._blue = -1\n\n    # Apply provided values through property setters to keep invariants.\n    if name is not None:\n        self.name = name\n    if hex is not None:\n        self.hex = hex\n    # Only set numeric channels if caller provided them (None means omitted)\n    if red is not None:\n        self.red = red\n    if green is not None:\n        self.green = green\n    if blue is not None:\n        self.blue = blue\n\n    # Fill missing values when possible\n    if self._name and not self._hex and self._name in get_css_map():\n        self.hex = get_css_map()[self._name]\n\n    if self._hex and (self._red &lt; 0 or self._green &lt; 0 or self._blue &lt; 0):\n        r, g, b = self.hex_to_rgb(self._hex)\n        self._red, self._green, self._blue = r, g, b\n\n    if not self._name and self._hex:\n        css_map = get_css_map() or get_css_map()\n        derived = _find_name_by_hex(self._hex, css_map)\n        if derived:\n            self._name = derived\n\n    # Final validation\n    if (\n        not self._name\n        or not self._hex\n        or any(v &lt; 0 or v &gt; 255 for v in (self._red, self._green, self._blue))\n    ):\n        raise ValueError(\"Unable to determine color.\")\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.__rich__","title":"<code>__rich__()</code>","text":"<p>Return a Rich Text representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __rich__(self) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the color.\"\"\"\n    return self.rich()\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.__str__","title":"<code>__str__()</code>","text":"<p>Return the name of the color. Returns:     str: The name of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the name of the color.\n    Returns:\n        str: The name of the color.\"\"\"\n    return f\"{self.name}\"\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.from_hex","title":"<code>from_hex(hex, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from a hex value.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_hex(cls, hex: str, css_map: Optional[dict[str, str]] = None) -&gt; \"CSSColor\":  # pylint:disable=W0622\n    \"\"\"Create a CSSColor instance from a hex value.\"\"\"\n    if not hex:\n        raise ValueError(\"Hex value must be a non-empty string.\")\n    css_map = css_map or get_css_map() or get_css_map()\n    norm_hex = _normalize_hex(hex)\n    name = _find_name_by_hex(norm_hex, css_map)\n    if name is None:\n        raise ValueError(f\"Unknown hex value: {hex}\")\n    red, green, blue = cls.hex_to_rgb(norm_hex)\n    return cls(name=name, hex=norm_hex, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.from_name","title":"<code>from_name(name, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from a color name.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_name(\n    cls, name: str, css_map: Optional[dict[str, str]] = None\n) -&gt; \"CSSColor\":\n    \"\"\"Create a CSSColor instance from a color name.\"\"\"\n    if not name:\n        raise ValueError(\"Name must be a non-empty string.\")\n    css_map = css_map or get_css_map()\n    norm = _normalize_name(name)\n    log.debug(f\"Creating CSSColor from name: name={norm!r}\")\n    hex_value = css_map.get(norm)\n    if not hex_value:\n        raise ValueError(f\"Unknown color name: {name}\")\n    red, green, blue = cls.hex_to_rgb(hex_value)\n    return cls(name=norm, hex=hex_value, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.from_rgb","title":"<code>from_rgb(red, green, blue, css_map=None)</code>  <code>classmethod</code>","text":"<p>Create a CSSColor instance from RGB values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@classmethod\ndef from_rgb(\n    cls,\n    red: int,\n    green: int,\n    blue: int,\n    css_map: Optional[dict[str, str]] = None,\n) -&gt; \"CSSColor\":\n    \"\"\"Create a CSSColor instance from RGB values.\"\"\"\n    for channel, label in ((red, \"red\"), (green, \"green\"), (blue, \"blue\")):\n        if not 0 &lt;= channel &lt;= 255:\n            raise ValueError(\n                f\"{label.capitalize()} value must be between 0 and 255.\"\n            )\n    css_map = css_map or get_css_map() or get_css_map()\n    hex_str = _hex_from_rgb(red, green, blue)\n    name = _find_name_by_hex(hex_str, css_map)\n    if name is None:\n        raise ValueError(f\"Unknown RGB values: ({red}, {green}, {blue})\")\n    return cls(name=name, hex=hex_str, red=red, green=green, blue=blue)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.hex_to_rgb","title":"<code>hex_to_rgb(hex_str)</code>  <code>staticmethod</code>","text":"<p>Return the RGB components as a tuple. Returns:     Tuple[int, int, int]: The RGB components.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@staticmethod\ndef hex_to_rgb(hex_str: str) -&gt; Tuple[int, int, int]:\n    \"\"\"Return the RGB components as a tuple.\n    Returns:\n        Tuple[int, int, int]: The RGB components.\n    \"\"\"\n    log.debug(f\"Converting hex to RGB: hex_str={hex_str!r}\")\n    norm = _normalize_hex(hex_str)\n    val = norm.lstrip(\"#\")\n    red, green, blue = (int(val[i : i + 2], 16) for i in (0, 2, 4))\n    log.debug(f\"Converted hex {norm} to RGB: red={red}, green={green}, blue={blue}\")\n    return (red, green, blue)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.panel","title":"<code>panel()</code>","text":"<p>Return a Rich Table representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def panel(self) -&gt; Panel:\n    \"\"\"Return a Rich Table representation of the color.\"\"\"\n    table = Table(\n        show_header=False,\n        show_edge=False,\n        show_lines=False,\n        pad_edge=True,\n        collapse_padding=False,\n        border_style=f\"bold {self.hex}\",\n    )\n\n    table.add_column(\"Hex\")\n    table.add_column(\"RGB\")\n    table.add_row(\n        Text(self.hex, style=f\"bold {self.hex}\"), Align(self.rgb(), align=\"center\")\n    )\n    return Panel(\n        table,\n        title=f\"[bold on {self.hex}] {self.name.capitalize()} [/bold on {self.hex}]\",\n        border_style=f\"bold {self.hex}\",\n        expand=False,\n        padding=(1, 4),\n    )\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.rgb","title":"<code>rgb(reverse=False)</code>","text":"<p>Return a Rich Text representation of the RGB values.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def rgb(self, reverse: bool = False) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the RGB values.\"\"\"\n    style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n    red_style = \"bold #AA0000\" if not reverse else f\"bold #AA0000 on {self.hex}\"\n    green_style = \"bold #00AA00\" if not reverse else f\"bold #00AA00 on {self.hex}\"\n    blue_style = \"bold #00AAFF\" if not reverse else f\"bold #00AAFF on {self.hex}\"\n\n    rgb = Text.assemble(*[\n        Text(\"rgb(\", style=style),\n        Text(f\"{self.red}\", style=red_style),\n        Text(\",\", style=style),\n        Text(f\"{self.green}\", style=green_style),\n        Text(\",\", style=style),\n        Text(f\"{self.blue}\", style=blue_style),\n        Text(\")\", style=style),\n    ])\n    return rgb\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColor.rich","title":"<code>rich(reverse=False)</code>","text":"<p>Return a Rich Text representation of the color.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def rich(self, reverse: bool = False) -&gt; Text:\n    \"\"\"Return a Rich Text representation of the color.\"\"\"\n    class_style = f\"bold {self.hex}\" if not reverse else f\"bold on {self.hex}\"\n    color_style = f\"bold on {self.hex}\" if reverse else f\"bold {self.hex}\"\n    label_style = f\"bold black on {self.hex}\" if reverse else \"bold white\"\n    return Text.assemble(*[\n        Text(\"CSSColor\", style=class_style),\n        Text(\"&lt;\", style=color_style),\n        Text(\"hex=\", style=label_style),\n        Text(f\"'{self.hex}'\", style=color_style),\n        Text(\", rgb='\", style=label_style),\n        self.rgb(reverse),\n        Text(\", name=\", style=label_style),\n        Text(f\"{self.name!r}'\", style=color_style),\n        Text(\"&gt;\", style=color_style),\n    ])\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColors","title":"<code>CSSColors</code>","text":"<p>               Bases: <code>Dict[str, CSSColor]</code></p> <p>Dictionary-like class to access CSS colors by name.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>class CSSColors(Dict[str, CSSColor]):\n    \"\"\"Dictionary-like class to access CSS colors by name.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        for color in get_css_colors():\n            self[color.name] = color\n\n    def __repr__(self) -&gt; str:\n        return f\"CSSColors({list(self.keys())})\"\n\n    def __contains__(self, item: object) -&gt; bool:\n        if not isinstance(item, str):\n            return False\n        key = _normalize_name(item)\n        return key in self.keys()\n\n    def __getitem__(self, item: str) -&gt; CSSColor:\n        if isinstance(item, str):\n            key = _normalize_name(item)\n            if key in self:\n                return super().__getitem__(key)\n            raise KeyError(item)\n        raise KeyError(item)\n\n    @property\n    def names(self) -&gt; List[str]:\n        \"\"\"Return a list of all CSS color names.\"\"\"\n        return list(self.keys())\n\n    @property\n    def hex_values(self) -&gt; List[str]:\n        \"\"\"Return a list of all CSS color hex values.\"\"\"\n        return [color.hex for color in self.values()]\n\n    @property\n    def triplets(self) -&gt; List[ColorTriplet]:\n        \"\"\"Return a list of all CSS color RGB triplets.\"\"\"\n        return [color.triplet for color in self.values()]\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.CSSColors.hex_values","title":"<code>hex_values</code>  <code>property</code>","text":"<p>Return a list of all CSS color hex values.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColors.names","title":"<code>names</code>  <code>property</code>","text":"<p>Return a list of all CSS color names.</p>"},{"location":"reference/css/#rich_color_ext.css.CSSColors.triplets","title":"<code>triplets</code>  <code>property</code>","text":"<p>Return a list of all CSS color RGB triplets.</p>"},{"location":"reference/css/#rich_color_ext.css.get_css_colors","title":"<code>get_css_colors(css_map=None)</code>","text":"<p>Return a list of all CSS colors defined in the JSON file.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>def get_css_colors(\n    css_map: Optional[dict[str, str]] = None,\n) -&gt; Generator[CSSColor, None, None]:\n    \"\"\"Return a list of all CSS colors defined in the JSON file.\"\"\"\n    if css_map is None:\n        css_map = get_css_map() or get_css_map()\n    yield from (CSSColor.from_name(color, css_map) for color in css_map)\n</code></pre>"},{"location":"reference/css/#rich_color_ext.css.get_css_map","title":"<code>get_css_map()</code>  <code>cached</code>","text":"<p>Return the mapping of CSS colour name (lowercase) \u2192 hex string (\u2018#RRGGBB\u2019). Loads the data on first call.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping colour name to hex.</p> Source code in <code>src/rich_color_ext/css.py</code> <pre><code>@lru_cache(maxsize=1024)\ndef get_css_map() -&gt; dict[str, str]:\n    \"\"\"\n    Return the mapping of CSS colour name (lowercase) \u2192 hex string (\u2018#RRGGBB\u2019).\n    Loads the data on first call.\n\n    Returns:\n        Dict mapping colour name to hex.\n    \"\"\"\n    css_map = {\n        \"aliceblue\": \"#f0f8ff\",\n        \"antiquewhite\": \"#faebd7\",\n        \"aqua\": \"#00ffff\",\n        \"aquamarine\": \"#7fffd4\",\n        \"azure\": \"#f0ffff\",\n        \"beige\": \"#f5f5dc\",\n        \"bisque\": \"#ffe4c4\",\n        \"black\": \"#000000\",\n        \"blanchedalmond\": \"#ffebcd\",\n        \"blue\": \"#0000ff\",\n        \"blueviolet\": \"#8a2be2\",\n        \"brown\": \"#a52a2a\",\n        \"burlywood\": \"#deb887\",\n        \"cadetblue\": \"#5f9ea0\",\n        \"chartreuse\": \"#7fff00\",\n        \"chocolate\": \"#d2691e\",\n        \"coral\": \"#ff7f50\",\n        \"cornflowerblue\": \"#6495ed\",\n        \"cornsilk\": \"#fff8dc\",\n        \"crimson\": \"#dc143c\",\n        \"cyan\": \"#00ffff\",\n        \"darkblue\": \"#00008b\",\n        \"darkcyan\": \"#008b8b\",\n        \"darkgoldenrod\": \"#b8860b\",\n        \"darkgray\": \"#a9a9a9\",\n        \"darkgreen\": \"#006400\",\n        \"darkgrey\": \"#a9a9a9\",\n        \"darkkhaki\": \"#bdb76b\",\n        \"darkmagenta\": \"#8b008b\",\n        \"darkolivegreen\": \"#556b2f\",\n        \"darkorange\": \"#ff8c00\",\n        \"darkorchid\": \"#9932cc\",\n        \"darkred\": \"#8b0000\",\n        \"darksalmon\": \"#e9967a\",\n        \"darkseagreen\": \"#8fbc8f\",\n        \"darkslateblue\": \"#483d8b\",\n        \"darkslategray\": \"#2f4f4f\",\n        \"darkslategrey\": \"#2f4f4f\",\n        \"darkturquoise\": \"#00ced1\",\n        \"darkviolet\": \"#9400d3\",\n        \"deeppink\": \"#ff1493\",\n        \"deepskyblue\": \"#00bfff\",\n        \"dimgray\": \"#696969\",\n        \"dimgrey\": \"#696969\",\n        \"dodgerblue\": \"#1e90ff\",\n        \"firebrick\": \"#b22222\",\n        \"floralwhite\": \"#fffaf0\",\n        \"forestgreen\": \"#228b22\",\n        \"fuchsia\": \"#ff00ff\",\n        \"gainsboro\": \"#dcdcdc\",\n        \"ghostwhite\": \"#f8f8ff\",\n        \"gold\": \"#ffd700\",\n        \"goldenrod\": \"#daa520\",\n        \"gray\": \"#808080\",\n        \"green\": \"#008000\",\n        \"greenyellow\": \"#adff2f\",\n        \"grey\": \"#808080\",\n        \"honeydew\": \"#f0fff0\",\n        \"hotpink\": \"#ff69b4\",\n        \"indianred\": \"#cd5c5c\",\n        \"indigo\": \"#4b0082\",\n        \"ivory\": \"#fffff0\",\n        \"khaki\": \"#f0e68c\",\n        \"lavender\": \"#e6e6fa\",\n        \"lavenderblush\": \"#fff0f5\",\n        \"lawngreen\": \"#7cfc00\",\n        \"lemonchiffon\": \"#fffacd\",\n        \"lightblue\": \"#add8e6\",\n        \"lightcoral\": \"#f08080\",\n        \"lightcyan\": \"#e0ffff\",\n        \"lightgoldenrodyellow\": \"#fafad2\",\n        \"lightgray\": \"#d3d3d3\",\n        \"lightgreen\": \"#90ee90\",\n        \"lightgrey\": \"#d3d3d3\",\n        \"lightpink\": \"#ffb6c1\",\n        \"lightsalmon\": \"#ffa07a\",\n        \"lightseagreen\": \"#20b2aa\",\n        \"lightskyblue\": \"#87cefa\",\n        \"lightslategray\": \"#778899\",\n        \"lightslategrey\": \"#778899\",\n        \"lightsteelblue\": \"#b0c4de\",\n        \"lightyellow\": \"#ffffe0\",\n        \"lime\": \"#00ff00\",\n        \"limegreen\": \"#32cd32\",\n        \"linen\": \"#faf0e6\",\n        \"magenta\": \"#ff00ff\",\n        \"maroon\": \"#800000\",\n        \"mediumaquamarine\": \"#66cdaa\",\n        \"mediumblue\": \"#0000cd\",\n        \"mediumorchid\": \"#ba55d3\",\n        \"mediumpurple\": \"#9370db\",\n        \"mediumseagreen\": \"#3cb371\",\n        \"mediumslateblue\": \"#7b68ee\",\n        \"mediumspringgreen\": \"#00fa9a\",\n        \"mediumturquoise\": \"#48d1cc\",\n        \"mediumvioletred\": \"#c71585\",\n        \"midnightblue\": \"#191970\",\n        \"mintcream\": \"#f5fffa\",\n        \"mistyrose\": \"#ffe4e1\",\n        \"moccasin\": \"#ffe4b5\",\n        \"navajowhite\": \"#ffdead\",\n        \"navy\": \"#000080\",\n        \"oldlace\": \"#fdf5e6\",\n        \"olive\": \"#808000\",\n        \"olivedrab\": \"#6b8e23\",\n        \"orange\": \"#ffa500\",\n        \"orangered\": \"#ff4500\",\n        \"orchid\": \"#da70d6\",\n        \"palegoldenrod\": \"#eee8aa\",\n        \"palegreen\": \"#98fb98\",\n        \"paleturquoise\": \"#afeeee\",\n        \"palevioletred\": \"#db7093\",\n        \"papayawhip\": \"#ffefd5\",\n        \"peachpuff\": \"#ffdab9\",\n        \"peru\": \"#cd853f\",\n        \"pink\": \"#ffc0cb\",\n        \"plum\": \"#dda0dd\",\n        \"powderblue\": \"#b0e0e6\",\n        \"purple\": \"#800080\",\n        \"rebeccapurple\": \"#663399\",\n        \"red\": \"#ff0000\",\n        \"rosybrown\": \"#bc8f8f\",\n        \"royalblue\": \"#4169e1\",\n        \"saddlebrown\": \"#8b4513\",\n        \"salmon\": \"#fa8072\",\n        \"sandybrown\": \"#f4a460\",\n        \"seagreen\": \"#2e8b57\",\n        \"seashell\": \"#fff5ee\",\n        \"sienna\": \"#a0522d\",\n        \"silver\": \"#c0c0c0\",\n        \"skyblue\": \"#87ceeb\",\n        \"slateblue\": \"#6a5acd\",\n        \"slategray\": \"#708090\",\n        \"slategrey\": \"#708090\",\n        \"snow\": \"#fffafa\",\n        \"springgreen\": \"#00ff7f\",\n        \"steelblue\": \"#4682b4\",\n        \"tan\": \"#d2b48c\",\n        \"teal\": \"#008080\",\n        \"thistle\": \"#d8bfd8\",\n        \"tomato\": \"#ff6347\",\n        \"turquoise\": \"#40e0d0\",\n        \"violet\": \"#ee82ee\",\n        \"wheat\": \"#f5deb3\",\n        \"white\": \"#ffffff\",\n        \"whitesmoke\": \"#f5f5f5\",\n        \"yellow\": \"#ffff00\",\n        \"yellowgreen\": \"#9acd32\",\n    }\n    return css_map\n</code></pre>"},{"location":"reference/hex_utils/","title":"Hex utils","text":"<p>Helpers for handling hex color codes.</p>"},{"location":"reference/hex_utils/#rich_color_ext.hex_utils.expand_3digit_hex","title":"<code>expand_3digit_hex(hex3)</code>","text":"<p>Expand a 3-digit hex string (e.g. '#ABC' or 'ABC') into a 6-digit with leading '#', e.g. '#AABBCC'.</p> <p>Parameters:</p> Name Type Description Default <code>hex3</code> <code>str</code> <p>The 3-digit hex string including or excluding the '#'.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string of format '#RRGGBB'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input is not a valid 3-digit hex representation.</p> Source code in <code>src/rich_color_ext/hex_utils.py</code> <pre><code>def expand_3digit_hex(hex3: str) -&gt; str:\n    \"\"\"\n    Expand a 3-digit hex string (e.g. '#ABC' or 'ABC') into a 6-digit with leading '#',\n    e.g. '#AABBCC'.\n\n    Args:\n        hex3: The 3-digit hex string including or excluding the '#'.\n\n    Returns:\n        A string of format '#RRGGBB'.\n\n    Raises:\n        ValueError: If input is not a valid 3-digit hex representation.\n    \"\"\"\n    hex_str = hex3.strip()\n    if hex_str.startswith(\"#\"):\n        hex_str = hex_str[1:]\n    if len(hex_str) != 3:\n        raise ValueError(f\"Invalid 3-digit hex colour: {hex3!r}\")\n    if any(c not in \"0123456789abcdefABCDEF\" for c in hex_str):\n        raise ValueError(f\"Invalid hex digit in {hex3!r}\")\n    red, green, blue = hex_str[0], hex_str[1], hex_str[2]\n    return f\"#{red}{red}{green}{green}{blue}{blue}\"\n</code></pre>"},{"location":"reference/hex_utils/#rich_color_ext.hex_utils.is_3digit_hex","title":"<code>is_3digit_hex(string)</code>","text":"<p>Test whether a string is a 3-digit hex colour code (#ABC or ABC) case-insensitive.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>input string.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if matches 3-digit hex format.</p> Source code in <code>src/rich_color_ext/hex_utils.py</code> <pre><code>def is_3digit_hex(string: str) -&gt; bool:\n    \"\"\"\n    Test whether a string is a 3-digit hex colour code (#ABC or ABC) case-insensitive.\n\n    Args:\n        string: input string.\n\n    Returns:\n        True if matches 3-digit hex format.\n    \"\"\"\n    hex_str = string.strip()\n    if hex_str.startswith(\"#\"):\n        hex_str = hex_str[1:]\n    return len(hex_str) == 3 and all(c in \"0123456789abcdefABCDEF\" for c in hex_str)\n</code></pre>"},{"location":"reference/hex_utils/#rich_color_ext.hex_utils.is_dark","title":"<code>is_dark(hex_str)</code>","text":"<p>Determine if a hex colour is 'dark' based on its luminance.</p> <p>Parameters:</p> Name Type Description Default <code>hex_str</code> <code>str</code> <p>A hex colour string of format '#RRGGBB'.</p> required <p>Returns:     True if the colour is dark, False otherwise.</p> Source code in <code>src/rich_color_ext/hex_utils.py</code> <pre><code>def is_dark(hex_str: str) -&gt; bool:\n    \"\"\"\n    Determine if a hex colour is 'dark' based on its luminance.\n\n    Args:\n        hex_str: A hex colour string of format '#RRGGBB'.\n    Returns:\n        True if the colour is dark, False otherwise.\n    \"\"\"\n    hex_str = hex_str.lstrip(\"#\")\n    if len(hex_str) != 6:\n        raise ValueError(f\"Invalid hex colour: {hex_str!r}\")\n    r = int(hex_str[0:2], 16)\n    g = int(hex_str[2:4], 16)\n    b = int(hex_str[4:6], 16)\n    # Calculate luminance using the Rec. 709 formula\n    luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b\n    return luminance &lt; 128\n</code></pre>"},{"location":"reference/hex_utils/#rich_color_ext.hex_utils.is_light","title":"<code>is_light(hex_str)</code>","text":"<p>Determine if a hex colour is 'light' based on its luminance.</p> <p>Parameters:</p> Name Type Description Default <code>hex_str</code> <code>str</code> <p>A hex colour string of format '#RRGGBB'.</p> required <p>Returns:     True if the colour is light, False otherwise.</p> Source code in <code>src/rich_color_ext/hex_utils.py</code> <pre><code>def is_light(hex_str: str) -&gt; bool:\n    \"\"\"\n    Determine if a hex colour is 'light' based on its luminance.\n\n    Args:\n        hex_str: A hex colour string of format '#RRGGBB'.\n    Returns:\n        True if the colour is light, False otherwise.\n    \"\"\"\n    return not is_dark(hex_str)\n</code></pre>"},{"location":"reference/modules/","title":"Modules","text":"<p>This page lists the main modules in the package for quick navigation.</p> <ul> <li><code>rich_color_ext.css</code> \u2014 CSS colour utilities and <code>CSSColor</code> helper class.</li> <li><code>rich_color_ext.patch</code> \u2014 Monkey-patch helpers for <code>rich.color.Color.parse</code>.</li> <li><code>rich_color_ext.hex_utils</code> \u2014 Helpers for 3-digit hex expansion and validation.</li> <li><code>rich_color_ext.cli</code> \u2014 CLI entry point.</li> <li><code>rich_color_ext.logger</code> \u2014 Internal logging wrapper.</li> </ul> <p>Click the module names in the Reference navigation to see the auto-generated API docs.</p>"},{"location":"reference/patch/","title":"Patch module","text":""},{"location":"reference/patch/#examples","title":"Examples","text":"<p>Patch Rich's <code>Color.parse</code> at runtime to add CSS name and 3-digit hex support:</p> <pre><code>from rich_color_ext.patch import install, uninstall, is_installed\n\ninstall()\nassert is_installed()\n\n# ... use Rich with CSS colours here ...\n\nuninstall()\nassert not is_installed()\n</code></pre>"},{"location":"reference/patch/#api-reference","title":"API reference","text":"<p>Monkey-patching support for rich.color.Color.parse.</p>"},{"location":"reference/patch/#rich_color_ext.patch.install","title":"<code>install()</code>","text":"<p>Install the monkey patch. After this call, rich.color.Color.parse will support 3\u2010digit hex and CSS colour names. Safe to call multiple times.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def install() -&gt; None:\n    \"\"\"\n    Install the monkey patch. After this call, rich.color.Color.parse will\n    support 3\u2010digit hex and CSS colour names. Safe to call multiple times.\n    \"\"\"\n    global INSTALLED  # pylint: disable=global-statement\n    if INSTALLED:\n        return\n    Color.parse = _patched_parse  # type: ignore[assignment]\n    INSTALLED = True\n</code></pre>"},{"location":"reference/patch/#rich_color_ext.patch.is_installed","title":"<code>is_installed()</code>","text":"<p>Return True if the monkey patch is currently installed.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def is_installed() -&gt; bool:\n    \"\"\"\n    Return True if the monkey patch is currently installed.\n    \"\"\"\n    return INSTALLED\n</code></pre>"},{"location":"reference/patch/#rich_color_ext.patch.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall the monkey patch, restoring the original rich.color.Color.parse. Safe to call multiple times.</p> Source code in <code>src/rich_color_ext/patch.py</code> <pre><code>def uninstall() -&gt; None:\n    \"\"\"\n    Uninstall the monkey patch, restoring the original rich.color.Color.parse.\n    Safe to call multiple times.\n    \"\"\"\n    global INSTALLED  # pylint: disable=global-statement\n    if not INSTALLED:\n        return\n    Color.parse = _ORIGINAL_PARSE  # type: ignore[assignment]\n    INSTALLED = False\n</code></pre>"}]}